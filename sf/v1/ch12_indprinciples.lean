import tactic.basic
import .ch07_indprop

/-
Check nat_ind.
-/

#check nat.rec_on

open nat

/-
Theorem mult_0_r' : ∀n:nat,
  n * 0 = 0.
Proof.
  apply nat_ind.
  - (* n = O *) reflexivity.
  - (* n = S n' *) simpl. intros n' IHn'. rewrite → IHn'.
    reflexivity. Qed.
-/

theorem mult_0_r' (n) : n * 0 = 0 :=
begin
  apply n.rec_on,
    refl,
  intros n' ih,
  /- i tried to get the ih in -/
  rw succ_mul,
  rw ih,
end

/-
Theorem plus_one_r' : ∀n:nat,
  n + 1 = S n.
Proof.
  (* FILL IN HERE *) Admitted.
-/

theorem plus_on_r' (n) : n + 1 = succ n :=
begin
  apply n.rec_on,
    refl,
  intros n' ih,
  rw ←ih,
end

/-
Inductive yesno : Type :=
  | yes
  | no.

Check yesno_ind.
(* ===> yesno_ind : forall P : yesno -> Prop,
                      P yes  ->
                      P no  ->
                      forall y : yesno, P y *)
-/

inductive yesno
| yes
| no

#check yesno.rec_on

/-
Inductive rgb : Type :=
  | red
  | green
  | blue.

Check rgb_ind.
-/

inductive rgb'
| red
| green
| blue

#check rgb.rec_on

/-
Inductive natlist : Type :=
  | nnil
  | ncons (n : nat) (l : natlist).

Check natlist_ind.
(* ===> (modulo a little variable renaming)
   natlist_ind :
      forall P : natlist -> Prop,
         P nnil  ->
         (forall (n : nat) (l : natlist),
            P l -> P (ncons n l)) ->
         forall n : natlist, P n *)
-/

inductive natlist
| nnil
| ncons (n : ℕ) (l : natlist)

#check natlist.rec_on

/-
Inductive natlist1 : Type :=
  | nnil1
  | nsnoc1 (l : natlist1) (n : nat).
-/

inductive natlist₁
| nnil₁
| nsnoc₁ (l : natlist₁) (n : ℕ)

#check natlist₁.rec_on

/-
Inductive byntree : Type :=
 | bempty
 | bleaf (yn : yesno)
 | nbranch (yn : yesno) (t1 t2 : byntree).
-/

inductive byntree
| bempty
| bleaf (yn : yesno)
| nbranch (yn : yesno) (t₁ t₂ : byntree)

#check byntree.rec_on

/-
Inductive ExSet : Type :=
  (* FILL IN HERE *)
.
-/

inductive ExSet
| con₁ (b : bool)
| con₂ (n : ℕ) (e : ExSet)

#check ExSet.rec_on

/-
Inductive list (X:Type) : Type :=
        | nil : list X
        | cons : X → list X → list X.
-/

inductive list' (α : Type)
| nil : list'
| cons : α → list' → list'

#check list'.rec_on

/-
Inductive tree (X:Type) : Type :=
  | leaf (x : X)
  | node (t1 t2 : tree X).

Check tree_ind.
-/

inductive tree (α : Type)
| leaf (a : α) : tree
| node (t₁ t₂ : tree) : tree

#check tree.rec_on

inductive mytype_ind (α : Type)
| constr₁ (a : α) : mytype_ind
| constr₂ (n : ℕ) : mytype_ind
| constr₃ (m : mytype_ind) (n : ℕ) : mytype_ind

#check mytype_ind.rec_on

inductive foo (α β : Type)
| bar (a : α) : foo
| baz (b : β) : foo
| quux (f₁ : ℕ → foo) : foo

#check foo.rec_on

/-
Inductive foo' (X:Type) : Type :=
  | C1 (l : list X) (f : foo' X)
  | C2.
-/

inductive foo' (α : Type)
| C₁ (l : list α) (f : foo') : foo'
| C₂ : foo'

#check foo'.rec_on

/-
Definition P_m0r (n:nat) : Prop :=
  n * 0 = 0.
-/

def P_m0r (n) := n * 0 = 0

/-
Definition P_m0r' : nat→Prop :=
  fun n ⇒ n * 0 = 0.
-/

def P_m0r' := λn, n * 0 = 0

/-
Theorem mult_0_r'' : ∀n:nat,
  P_m0r n.
Proof.
  apply nat_ind.
  - (* n = O *) reflexivity.
  - (* n = S n' *)
    (* Note the proof state at this point! *)
    intros n IHn.
    unfold P_m0r in IHn. unfold P_m0r. simpl. apply IHn. Qed.
-/

theorem mult_0_r'' (n) : P_m0r n :=
begin
  apply n.rec_on,
    unfold P_m0r,
    refl,
  intros n ih,
  unfold P_m0r at ih,
  unfold P_m0r,
  rw succ_mul,
  apply ih,
end

/-
Theorem plus_assoc' : ∀n m p : nat,
  n + (m + p) = (n + m) + p.
Proof.
  (* ...we first introduce all 3 variables into the context,
     which amounts to saying "Consider an arbitrary n, m, and
     p..." *)
  intros n m p.
  (* ...We now use the induction tactic to prove P n (that
     is, n + (m + p) = (n + m) + p) for _all_ n,
     and hence also for the particular n that is in the context
     at the moment. *)
  induction n as [| n'].
  - (* n = O *) reflexivity.
  - (* n = S n' *)
    (* In the second subgoal generated by induction -- the
       "inductive step" -- we must prove that P n' implies
       P (S n') for all n'.  The induction tactic
       automatically introduces n' and P n' into the context
       for us, leaving just P (S n') as the goal. *)
    simpl. rewrite → IHn'. reflexivity. Qed.
-/

theorem plus_assoc''' (n m p : ℕ)
  : n + (m + p) = ((n + m) + p) :=
begin
  induction n with n' ih,
    repeat { rw zero_add, },
  rw succ_add,
  rw ih,
  repeat { rw ←succ_add, },
end

/-
Theorem plus_comm' : ∀n m : nat,
  n + m = m + n.
Proof.
  induction n as [| n'].
  - (* n = O *) intros m. rewrite <- plus_n_O. reflexivity.
  - (* n = S n' *) intros m. simpl. rewrite → IHn'.
    rewrite <- plus_n_Sm. reflexivity. Qed.
-/

/- does not work in lean -/
-- theorem plus_comm'
--   : ∀n m : ℕ, n + m = m + n :=
-- begin
--   induction n with n' ih,
-- end

/-
Theorem plus_comm'' : ∀n m : nat,
  n + m = m + n.
Proof.
  (* Let's do induction on m this time, instead of n... *)
  induction m as [| m'].
  - (* m = O *) simpl. rewrite <- plus_n_O. reflexivity.
  - (* m = S m' *) simpl. rewrite <- IHm'.
    rewrite <- plus_n_Sm. reflexivity. Qed.
-/

/- does not work in lean -/

def p_assoc (n m p : ℕ)
  := n + (m + p) = ((n + m) + p)

theorem plus_assoc'''' (n m p) : p_assoc n m p :=
begin
  induction n with n' ih,
    unfold p_assoc,
    repeat { rw zero_add },
  unfold p_assoc at *,
  rw [succ_add, ih, ←succ_add, ←succ_add],
end

def p_comm (n m : ℕ) := n + m = m + n

theorem plus_comm' (n m) : p_comm n m :=
begin
  induction n with n' ih generalizing m,
    unfold p_comm,
    rw zero_add,
    refl,
  unfold p_comm at *,
  rw [succ_add, ih],
end

/-
Inductive even : nat → Prop :=
    | ev_0 : even 0
    | ev_SS : ∀n : nat, even n → even (S (S n)).
-/

inductive even''' : ℕ → Prop
| ev_0 : even''' 0
| ev_SS : ∀n, even''' n → even''' (succ (succ n))

#check even.rec_on

theorem even'''_even'' {n} (h: even''' n) : even'' n :=
begin
  apply h.rec_on,
    exact even''.even''_0,
  intros n hn ih,
  exact even''.even''_sum n 2 ih (even''.even''_2),
end

inductive le' (n : ℕ) : ℕ → Prop
| le_n : le' n
| le_S (m) (h : le' m) : le' (succ m)

#check le.rec_on
#check le'.rec_on
